#coding = utf-8

"""
## 哨兵排序法
对于待排序的序列，如果在原位置上进行比较和移动操作，通常需要声明额外的临时变量用于保存将要被替换位置的值。
所以在进行遍历取值同某个参考量进行比较时，需要考虑遍历过程不能超出序列边界（程序中可能会利用如range范围限定）。 

这里将一个哨兵位和原未排序的序列共同组成一个n+1长度的序列，每次读取新值与已经有序序列最后位进行比较，如果新值更小则先报错到哨兵位，然后再从已排好序的序列最高为开始依次与哨兵进行比较，这时候的比较就发挥哨兵位于数组【0】位置的优点，遍历条件while ls[j-1] > ls[0] 很自然的实现序列最后的元素与哨兵进行比较，遍历到哨兵时自然不符合; 如果采用额外声明变量，则遍历时除了有大小比较还要限定遍历的范围
"""

def insert_sort(ls, n):
  for i in range(2, n+1):
    # 0位为哨兵，所以从第2位和第1位进行比较
    
    if ls[i] < ls[i - 1]:
      ls[0] = ls[i]
      j = 1
      while ls[j - 1] > ls[0]:
        ls[j] = ls[j - 1]
        j -= 1
      ls[j] = ls[0]


if __name__ == '__main__':
  list = [8,7,16,13,4,25]
  
  ls = [-999]  # 哨兵为足够小的数
  ls.extend(list)
  insert_sort(ls, 6)
  
